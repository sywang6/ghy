类加载的过程:
       |------------------|
加载 -> |验证 -> 准备 -> 解析| -> 初始化 -> 使用 -> 卸载
       |__________________|
.验证,准备,解析这三个步骤统称为连接, 解析可能发生在初始化之前也可能发生在初始化之后.加载,验证,准备,初始化,使用,卸载则需要
 按照严格的顺序开始,但是并不一定按照这个顺序结束.

什么时候需要立即对类进行初始化?对一个类型进行主动引用的时候.被动引用时候则不会触发初始化.
.遇到new,getstatic,putstatic,invokestatic这四条字节码指令时,如果类型没有进行过初始化,则需要先触发其初始化阶段.能够生成这四条指令的典型java代码
 场景有:
 1)使用new关键字实例化对象的时候
 2)读取或设置一个类型的静态字段(被final修饰,已在编译期把结果放入常量池的静态字段除外)的时候
 3)调用一个类型的静态方法的时候
.使用java.lang.reflect包的方法对类型进行反射调用的时候,如果类型没有进行过初始化,则需要先触发其初始化.
.当初始化类的时候,如果发现其父类还没有进行过初始化,则需要先触发其父类的初始化.
.当虚拟机启动时,用户要指定一个要执行的主类(包含main()方法的那个类),虚拟机会先初始化这个主类
.当使用JDK7新加入的动态语言支持时,如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic,REF_putStatic,REF_invokeStatic
 ,REF_newInvokeSpecial四种类型的方法句柄,并且这个方法句柄对应的类没有进行过初始化,则需要先触发其初始化.
.当一个接口中定义了JDK8新加入的默认方法(被default关键字修饰的接口方法)时,如果有这个接口的实现发生了初始化,那该接口要在其之前被初始化.

被动引用的例子,参考NotInitialization,NotInitialization2,NotInitialization3

接口加载过程:与类的加载稍有区别,当一个类初始化时,要求其父类全部都已经初始化过了,但一个接口在初始化时,并不要求其符接口都完成了初始化,
只有在真正使用到父接口的时候(如引用接口中定义的常量)才化初始化

加载:
.类的二进制流从哪里来?
    从ZIP压缩包中读取,jar,war,ear
    网络二进制流,Web Applet
    运行时计算生成,动态代理
    由其他文件生成,JSP
    从数据库读取
    从加密文件获取,防class文件被反编译的包含措施
.如何加载?类加载器

验证:
    文件格式验证
    元数据验证
    字节码验证,1)类型推导验证(JDK7之后以废弃) 2)类型检查验证,StackMapTable属性
    符号引用验证

准备:
    类变量分配内存并设置初始值.jdk7之前:HotSpot在永久代实现方法区.jdk8及之后:类变量会随着Class对象一起存放在Java堆中
    一般都是零值.常量(基本类型和字符串类型)为指定的常量值
	-----------------------------------------|
	|数据类型	|零值	  |数据类型	  |零值  |
	|int		|0	      |boolean	  |false |
	|long		|0L		  |float	  | 0.0f |
	|short		|(short)0 |double	  | 0.0d |
	|char		|'\u0000' |reference  | null |
	|byte		|(byte)0  |           |      |
	------------------------------------------
解析:
    符号引用:符号引用以一组符号来描述所引用的目标,符号可以是任何形式的字面量,只要使用时能无歧义地定位到目标即可.
    直接引用:直接引用是可以直接指向目标的指针,相对偏移量或者是一个能间接定位带目标的句柄.
.类或接口的解析:
    当前代码所处的类为D,把一个从未解析过的符号引用N解析为一个类或接口的C的直接引用.
    1).如果C不是一个数组类型,那虚拟机将会把代表N的全限定名传递给D的类加载器去加载这类C.在加载过程中,由于元数据验证,字节码验证的需要,又可能触发其他相关类的
       加载动作,例如加载这个类的父类或实现的接口.一旦这个加载过程出现了任何异常,解析过程就将宣告失败.
    2).如果C是一个数组类型,并且数组的元素类型为对象,那将会按照第一点的规则加载数组元素类型.例如N的描述符为"[Ljava/lang/Integer"的形式,需要加载的元素类型就是
       "java.lang.Integer",接着由虚拟机生成一个代表该数组维度和元素的数组对象.
    3).如果上面两步没有出现任何异常,那么C在虚拟机中实际上已经成为一个有效的类或接口了,但在解析完成前还要进行符号引用验证,确认D是否具备对C的访问权限.如果发现不具备访问权限
    ,将抛出java.lang.IllegalAccessError异常.
    模块间的访问权限校验: D拥有C的访问权限,那就意味着以下3条规则中至少有其中一条成立:
        .被访问类C是public的,并且与访问类D处于同一个模块
        .被访问类C是public的,不与访问类D处于同一个模块,但是被访问类C的模块允许访问类D的模块进行访问
        .被访问类C不是public的,但是它与访问类D处于同一个包中.
.字段解析
    要解析一个未被解析过的字段符号引用,首先会对字段表内class_index项中索引的CONSTANT_Class_info符号引用进行解析,也就是字段所属的类或接口的符号引用.
    如果在解析这个类或接口符号引用的过程中出现了任何异常,都会导致字段符号引用解析的失败.如果解析成功完成,那把这个字段所属的类或接口用C表示,<<java虚拟机规范>>
    要求按照如下步骤对C进行后续字段的搜索:
        1).如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段,则返回这个字段的直接引用,查找结束.
        2).否则,如果在C中实现了接口,将按照继承关系从下往上递归搜索各接口和它的父接口,如果接口中包含了简单名称和字段描述符都与目标相匹配的字段,则返回这个字段的直接引用,
         查找结束.
        3).否则,如果C不是java.lang.Object的话,将会按照继承关系从下往上递归搜索其父类,如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段,则返回这个字段的
           直接引用,查找结束.
        4)否则,查找失败,抛出java.lang.NoSuchFieldError异常
    javac编译器比上述规范更加严格一点:譬如有一个同名字段同时出现在某个类的接口和父类当中,或者同时在自己或父亲的多个接口中出现,按照解析规则仍是可以确定唯一的访问字段
    ,但javac编译器就可能拒绝其编译为Class文件.
.方法解析
    方法解析的第一个步骤与字段解析一样,也是需要先解析出方法表的class_index项中索引的方法所属的类或接口的符号引用,如果解析成功,那么我们依然用C表示这个类,接下来虚拟机
    将会按照如下步骤进行后续的方法搜索:
        1).由于Class文件格式中类的方法和接口的方法符号引用的常量类型定义是分开的,如果在类的方法表中发现class_index中索引的C是个接口的话,那就直接抛出java.lang.
        IncompatibleClassError异常.
        2).如果通过了第一步,在类C中查找是否有简单名称和描述符都与目标相匹配的方法,如果有则返回这个方法的直接引用,查找结束.
        3).否则,在类C的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法,如果有则返回这个方法的直接引用.查找结束.
        4).否则,在类C实现的接口列表及他们的父接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法,如果存在匹配的方法,说明类C是一个抽象类,这时候查找结束,
        抛出java.lang.AbstractMethodError异常.
        5).否则,宣告方法查找失败,抛出java.lang.NoSuchMethodError.
.接口方法解析
    接口方法也是需要先解析出接口方法表的class_index项中索引的方法所属的类或接口的符号引用,如果解析成功,依然用C表示这个接口,接下来虚拟机将会按照如下步骤进行后续的
    接口方法搜索:
    1).与类的方法解析相反,如果在接口方法表发现class_index中的索引C是个类而不是接口,那么就直接抛出java.lang.IncompatibleClassChangeError异常.
    2).否则,在接口C中查找是否有简单名称和描述符都与目标相匹配的方法,如果有则返回这个方法的直接引用,查找结束.
    3).否则,在接口C的父接口中递归查找,直到java.lang.Object类(接口方法的查找范围会包括Object类中的方法)为止,看是否有简单名称和描述符都与目标相匹配的方法,如果有则
       返回这个方法的直接引用,查找结束
    4)对应规则3,由于java的接口允许多重继承,如果C的不同父接口中存有多个简单名称和描述符都与目标相匹配的方法,那将会从这多个方法中返回其中一个并结束查找,<<java虚拟机规范>>
      中并没有进一步规则约束应该返回哪一个接口方法.但与之前字段查找类似地,不同发行商实现的javac编译器有可能会按照更严格的约束拒绝编译这种代码来避免不确定性.
    5).否则,宣告方法查找失败,抛出java.lang.NoSuchMethodError异常.
    jdk9之前方法默认是public的,没有访问权限的问题.jdk9之后加入模块化和接口静态私有方法,如果没有访问权限出抛出java.lang.IllegalAccessError异常

初始化:
    .<clinit>()方法编译器自动收集类中所有类变量的赋值动作和静态语句块(static{}块)中的语句合并产生的,编译器收集的顺序是由语句在源文件中出现的顺序决定的.
    .定义在静态语句块之后的静态变量,在静态语句块里面只能赋值,不能访问.
     public class Test{
        static{
            i = 0; //给静态变量赋值可以正常编译通过
            System.out.print(i); //这个编译器会提示"非法向前引用"
        }
        static int i = 1;
     }
     .虚拟机会保证子类的<clinit>方法执行前,父类的<clinit>()方法已经执行完毕.
     .<clinit>()方法对于类或接口来说并不是必须的.一个类中没有静态语句块,也没有对静态变量的赋值操作,那么编译器可以不为这个类生成<clinit>方法
     .接口中有静态变量初始化赋值操作,因此接口与类一样都会生成<clinit>方法.但接口与类不同的是,执行接口的<clinit>()方法不需要执行父接口的<clinit>
      方法,因为只有当父接口中定义的变量被使用时,父接口才会被初始化.接口的实现类在初始化时也一样不会执行接口的<clinit>方法
     .<clinit>方法在多线程环境中被正确地加锁同步,且只会执行一次.



















