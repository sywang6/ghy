类加载的过程:
       |------------------|
加载 -> |验证 -> 准备 -> 解析| -> 初始化 -> 使用 -> 卸载
       |__________________|
.验证,准备,解析这三个步骤统称为连接, 解析可能发生在初始化之前也可能发生在初始化之后.加载,验证,准备,初始化,使用,卸载则需要
 按照严格的顺序开始,但是并不一定按照这个顺序结束.

什么时候需要立即对类进行初始化?对一个类型进行主动引用的时候.被动引用时候则不会触发初始化.
.遇到new,getstatic,putstatic,invokestatic这四条字节码指令时,如果类型没有进行过初始化,则需要先触发其初始化阶段.能够生成这四条指令的典型java代码
 场景有:
 1)使用new关键字实例化对象的时候
 2)读取或设置一个类型的静态字段(被final修饰,已在编译期把结果放入常量池的静态字段除外)的时候
 3)调用一个类型的静态方法的时候
.使用java.lang.reflect包的方法对类型进行反射调用的时候,如果类型没有进行过初始化,则需要先触发其初始化.
.当初始化类的时候,如果发现其父类还没有进行过初始化,则需要先触发其父类的初始化.
.当虚拟机启动时,用户要指定一个要执行的主类(包含main()方法的那个类),虚拟机会先初始化这个主类
.当使用JDK7新加入的动态语言支持时,如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic,REF_putStatic,REF_invokeStatic
 ,REF_newInvokeSpecial四种类型的方法句柄,并且这个方法句柄对应的类没有进行过初始化,则需要先触发其初始化.
.当一个接口中定义了JDK8新加入的默认方法(被default关键字修饰的接口方法)时,如果有这个接口的实现发生了初始化,那该接口要在其之前被初始化.

被动引用的例子,参考NotInitialization,NotInitialization2,NotInitialization3

接口加载过程:与类的加载稍有区别,当一个类初始化时,要求其父类全部都已经初始化过了,但一个接口在初始化时,并不要求其符接口都完成了初始化,
只有在真正使用到父接口的时候(如引用接口中定义的常量)才化初始化

加载:
.类的二进制流从哪里来?
    从ZIP压缩包中读取,jar,war,ear
    网络二进制流,Web Applet
    运行时计算生成,动态代理
    由其他文件生成,JSP
    从数据库读取
    从加密文件获取,防class文件被反编译的包含措施
.如何加载?类加载器

验证:
    文件格式验证
    元数据验证
    字节码验证,1)类型推导验证(JDK7之后以废弃) 2)类型检查验证,StackMapTable属性
    符号引用验证

准备:
    类变量分配内存并设置初始值.jdk7之前:HotSpot在永久代实现方法区.jdk8及之后:类变量会随着Class对象一起存放在Java堆中
    一般都是零值.常量(基本类型和字符串类型)为指定的常量值
	-----------------------------------------|
	|数据类型	|零值	  |数据类型	  |零值  |
	|int		|0	      |boolean	  |false |
	|long		|0L		  |float	  | 0.0f |
	|short		|(short)0 |double	  | 0.0d |
	|char		|'\u0000' |reference  | null |
	|byte		|(byte)0  |           |      |
	------------------------------------------
解析:
    符号引用:符号引用以一组符号来描述所引用的目标,符号可以是任何形式的字面量,只要使用时能无歧义地定位到目标即可.
    直接引用:直接引用是可以直接指向目标的指针,相对偏移量或者是一个能间接定位带目标的句柄.
.类或接口的解析:
    当前代码所处的类为D,把一个从未解析过的符号引用N解析为一个类或接口的C的直接引用.
    1).





















